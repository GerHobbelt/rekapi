<!DOCTYPE html>
<html>
<head>
  <script>
  var mockTime = function () {
    return +(new Date());
  };
  var global = window;
  </script>
  <link href="../bower_components/qunit/qunit/qunit.css" rel="stylesheet" type="text/css" />
  <script src="../bower_components/qunit/qunit/qunit.js"></script>
  <script src="../bower_components/lodash/dist/lodash.js"></script>
  <script src="/assets/rekapi.js"></script>
  <script>
  function setupTestRekapi () {
    return new Rekapi();
  }

  function  setupTestActor (forRekapi) {
    var actor = new Rekapi.Actor();
    forRekapi.addActor(actor);
    return actor;
  }

  (function () {

    var Tweenable = Rekapi.shifty.Tweenable;
    var setBezierFunction = Rekapi.shifty.setBezierFunction;
    var unsetBezierFunction = Rekapi.shifty.unsetBezierFunction;

    Tweenable.now = function () {
      return mockTime();
    };

    module('addActor');

    test('Actors are added successfully', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      equal(rekapi._actors[actor.id], actor,
          'Actor is in the internal _actors Object');
    });


    test('Actors can only be added once', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      rekapi.addActor(actor);

      equal(rekapi.getActorCount(), 1,
          'The actor was not added twice');
    });


    test('Actors can be retrieved from the Rekapi', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      equal(rekapi.getActor(actor.id), actor,
          'Can reference the Actor inside the Rekapi via the actor ID');
    });

    test('Supplying an object instantiates an actor', function () {
      var rekapi = setupTestRekapi();
      var actorContext = {};
      var actor = rekapi.addActor({ context: actorContext });

      ok(actor instanceof Rekapi.Actor,
          'addActor made an instance of Rekapi.Actor');
      ok(actorContext === actor.context,
          'The instantiated actor has the correct context');
    });


    module('removeActor');


    test('Actors are removed successfully', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      rekapi.removeActor(actor)

      equal(rekapi._actors[actor.id], undefined,
          'Actor is no longer in the internal _actors Object');

      equal(_.indexOf(rekapi._renderOrder, actor.id), -1,
          'Actor is not in the internal _renderOrder array');
    });


    module('removeAllActors');


    test('All actors are removed successfully', function () {
      var rekapi
          ,actor
          ,actor2;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      actor2 = setupTestActor(rekapi);
      var removedActors = rekapi.removeAllActors();

      equal(_.size(rekapi._actors), 0,
          'Actors were removed from the internal _actors Object');

      var filteredRemovedActors = _.filter(removedActors, function (actor) {
        return actor instanceof Rekapi.Actor;
      });

      equal(filteredRemovedActors.length, 2,
          'Removed actors were returned from the operation');
    });


    module('getActorIds');


    test('Can get actor IDs', function () {
      var rekapi
          ,actor
          ,actor2;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      actor2 = setupTestActor(rekapi);

      var ids = rekapi.getActorIds();

      equal(ids.length, 2,
          'Number of IDs equal the number of Actors that were added');
      equal(_.contains(ids, actor.id), true,
          'First Actor\'s ID is present in the ID list');
      equal(_.contains(ids, actor2.id), true,
          'Second Actor\'s ID is present in the ID list');
    });


    module('getAllActors');


    test('Can get actors', function () {
      var rekapi
          ,actor
          ,actor2;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      actor2 = setupTestActor(rekapi);

      var actors = rekapi.getAllActors();

      equal(actors[actor.id], actor,
          'First Actor was extracted');
      equal(actors[actor2.id], actor2,
          'Second Actor was extracted');
    });


    module('getActor');


    test('Actors can be retrieved from the Rekapi', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      equal(rekapi.getActor(actor.id), actor,
          'Can reference the Actor inside the Rekapi via the actor ID.');
    });


    module('getAnimationLength');


    test('Calculate animation length with one Actor', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 1 })
        .keyframe(1000, { x: 2 })
        .keyframe(2000, { x: 3 });

      equal(rekapi.getAnimationLength(), 2000,
          'Length of the animation was calculated');
    });


    test('Calculate animation length with multiple Actors', function () {
      var rekapi
          ,actor
          ,actor2;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      actor2 = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 1})
        .keyframe(1000, { x: 2})
        .keyframe(2000, { x: 3});

      actor2
        .keyframe(0, { x: 1 })
        .keyframe(5000, { x: 2 });

      equal(rekapi.getAnimationLength(), 5000,
          'Length of the animation was calculated');
    });


    module('exportTimeline');


    test('Exported Rekapi data has key data points', function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);
      actor.keyframe(0, {
        'x': 1
      }).keyframe(1000, {
        'x': 2
      });

      var exportedTimeline = rekapi.exportTimeline();
      equal(exportedTimeline.duration, 1000,
          'Duration was exported');
      deepEqual(exportedTimeline.actors[0],
          actor.exportTimeline(),
          'Actor was exported');
    });

    test('Custom easing curves are exported', function () {
      setBezierFunction('custom', 0, .25, .5, .75);
      var rekapi = setupTestRekapi();
      console.log(Tweenable.formulas)

      var exportedTimeline = rekapi.exportTimeline();
      deepEqual(
        exportedTimeline.curves,
        { custom: { displayName: 'custom', x1: 0, y1: .25, x2: .5, y2: .75 }},
        'custom curve was exported with bezier points');

      // Clean up Tweenable
      unsetBezierFunction('custom');
    });


    module('importTimeline');


    test('Exported Rekapi data re-imports correctly', function () {
      var exportRekapi
          ,exportActor;

      exportRekapi = setupTestRekapi();
      exportActor = setupTestActor(exportRekapi);
      exportActor.keyframe(0, {
        'x': 1
      }).keyframe(1000, {
        'x': 2
      });

      var exportedTimeline = exportRekapi.exportTimeline();
      var importRekapi = new Rekapi();
      importRekapi.importTimeline(exportedTimeline);

      deepEqual(importRekapi.exportTimeline(), exportedTimeline,
          'Rekapi exports the same data that was imported');
    });

    test('Exported custom curves re-import correctly', function () {
      setBezierFunction('custom', 0, .25, .5, .75);
      var rekapi = setupTestRekapi();

      var exportedTimeline = rekapi.exportTimeline();

      // Reset for a clean test
      unsetBezierFunction('custom');

      var importRekapi = new Rekapi();
      importRekapi.importTimeline(exportedTimeline);

      ok(typeof Tweenable.formulas.custom === 'function',
        'Rekapi redefined custom formula');
      equal(Tweenable.formulas.custom.x1, 0, 'Imported x1');
      equal(Tweenable.formulas.custom.y1, .25, 'Imported y1');
      equal(Tweenable.formulas.custom.x2, .5, 'Imported x2');
      equal(Tweenable.formulas.custom.y2, .75, 'Imported y2');

      // Clean up Tweenable
      unsetBezierFunction('custom');
    });


    module('on');


    test('Event is fired when an actor is added', function () {

      var rekapi = setupTestRekapi();
      var actor = new Rekapi.Actor();

      rekapi.on('addActor', function(rekapi, actor) {
        ok(actor !== undefined);
        equal(actor, actor, 'Event data is equal to added actor');
      });
      rekapi.addActor(actor);
    });


    test('Event is fired when an actor is removed', function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      rekapi.on('removeActor', function(rekapi, actor) {
        ok(actor !== undefined);
        equal(actor, actor, 'Event data is equal to removed actor');
      });
      rekapi.removeActor(actor);
    });


    module('off');

    test('Event handlers are  are not called after being unbound',
        function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);
      var handlerWasCalled = false;

      rekapi.on('addActor', function(rekapi, actor) {
        handlerWasCalled = true;
      });
      rekapi.addActor(actor);

      ok(!handlerWasCalled, 'Handler was not called');
    });


    module('trigger');


    test('A bound event can be manually triggered', function () {

      var rekapi = setupTestRekapi();
      var eventWasTriggered = false;
      var providedData;

      rekapi.on('timelineModified', function (rekapi, data) {
        eventWasTriggered = true;
        providedData = data;
      });

      rekapi.trigger('timelineModified', 5);
      ok(eventWasTriggered, 'timelineModified was manually triggered');
      equal(providedData, 5, 'Data was provided to the event');
    });


    module('getLastPositionUpdated');


    test('Last calculated state is recorded', function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(0, {
        'x': 1
      }).keyframe(1000, {
        'x': 2
      });

      rekapi.update(500);
      equal(rekapi.getLastPositionUpdated(), .5, 'Midpoint was recorded');
    });


    module('getLastMillisecondUpdated');


    test('Last calculated state is recorded in milliseconds', function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor.keyframe(0, {
        'x': 1
      }).keyframe(1000, {
        'x': 2
      });

      rekapi.update(500);
      equal(rekapi.getLastMillisecondUpdated(), 500, 'Midpoint was recorded');
    });


    module('getActorCount');

    test('Actors are accounted for', function () {

      var rekapi = new Rekapi();
      rekapi.addActor(new Rekapi.Actor());
      rekapi.addActor(new Rekapi.Actor());
      rekapi.addActor(new Rekapi.Actor());
      equal(rekapi.getActorCount(), 3, 'All actors were added and recorded');
    });


    module('update');


    test('update causes the actor states to be recalculated', function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 0 })
        .keyframe(1000, { x: 10 });

      rekapi.update(500);

      equal(actor.get().x, 5, 'Midpoint of the actor was computed');
    });


    test('Calling update with no parameters causes the animation to update to the last rendered millisecond',
        function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 0 })
        .keyframe(1000, { x: 10 });

      rekapi.update(250);
      equal(actor.get().x, 2.5,
          'The explicitly defined millisecond was updated');

      // Simulate the state of rekapi if it was stopped at millisecond 500
      rekapi._lastUpdatedMillisecond = 500;

      rekapi.update();

      equal(actor.get().x, 5,
          'The last milliscond updated was recomputed');
    });


    module('isPlaying');


    test('Check the playing state of an animation', function () {

      mockTime = function () {
        return new Date();
      };

      var rekapi = setupTestRekapi();
      rekapi.play();
      equal(rekapi.isPlaying(), true,
          '.play() causes .isPlaying() to be true');

      rekapi.pause();
      equal(rekapi.isPlaying(), false,
          '.pause() causes .isPlaying() to be false');

      rekapi.stop();
      equal(rekapi.isPlaying(), false,
          '.stop() causes .isPlaying() to be false');
    });


    module('pause');


    test('Resuming a paused animation starts where it left off', function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(1000, {})
        .keyframe(2000, {});


      mockTime = function () {
        return 0;
      };

      rekapi.play();

      mockTime = function () {
        return 500;
      };

      rekapi.pause();

      mockTime = function () {
        return 1500;
      };

      rekapi.play();

      equal(rekapi._loopTimestamp, 1000,
          '.pause() modifies the internal timestamp of the animation');
    });


    module('isPaused');


    test('Check the paused state of an animation', function () {

      mockTime = function () {
        return new Date();
      };

      var rekapi = setupTestRekapi();
      rekapi.play();
      equal(rekapi.isPaused(), false,
          '.play() causes .isPaused() to be false');

      rekapi.pause();
      equal(rekapi.isPaused(), true,
          '.pause() causes .isPaused() to be true');

      rekapi.stop();
      equal(rekapi.isPaused(), false,
          '.stop() causes .isPaused() to be false');
    });


    module('stop');


    test('Re-starting a stopped animation starts where from the beginning',
      function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(1000, {})
        .keyframe(2000, {});


      mockTime = function () {
        return 0;
      };

      rekapi.play();

      mockTime = function () {
        return 500;
      };

      rekapi.stop();

      mockTime = function () {
        return 1500;
      };

      rekapi.play();

      equal(rekapi._loopTimestamp, 1500,
          '.stop() resets the timestamp of the animation');
    });


    test('Resets function keyframes', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor
        .keyframe(10, {
          'function': function () {
            callCount++;
          }
        })
        .keyframe(20, {
          'function': function () {
            callCount++;
          }
        });

      rekapi.play();

      Rekapi._private.updateToMillisecond(rekapi, 5);
      equal(callCount, 0, 'The function was not called');

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 1, 'The function was called once');

      rekapi.stop();

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 2, 'The function was called twice');
    });


    module('isStopped');


    test('Check the stopped state of an animation', function () {

      mockTime = function () {
        return new Date();
      };

      var rekapi = setupTestRekapi();
      rekapi.play();
      equal(rekapi.isStopped(), false,
          '.play() causes .isStopped() to be false');

      rekapi.pause();
      equal(rekapi.isStopped(), false,
          '.pause() causes .isStopped() to be false');

      rekapi.stop();
      equal(rekapi.isStopped(), true,
          '.stop() causes .isStopped() to be true');
    });


    module('playFrom');


    test('Can start an animation from an arbitrary point on the timeline',
      function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(1000, {});

      mockTime = function () {
        return 3000;
      };

      rekapi.playFrom(500);

      equal(rekapi._loopTimestamp, 2500,
          '.playFrom resets the timestamp');
    });

    test('Reset function keyframes later but not before specified millisecond', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor
        .keyframe(10, {
          'function': function () {
            callCount++;
          }
        })
        .keyframe(20, {
          'function': function () {
            callCount++;
          }
        });

      rekapi._timesToIterate = 1;

      Rekapi._private.updateToMillisecond(rekapi, 5);
      equal(callCount, 0, 'The function was not called');

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 1, 'The function was called once');

      rekapi.playFrom(5);
      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 2, 'The function was called twice');
    });


    module('playFromCurrent');


    test('Can calculate any point on the timeline and playFromCurrent()',
      function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(1000, {});

      mockTime = function () {
        return 3000;
      };

      rekapi.update(500);
      rekapi.playFromCurrent();

      equal(rekapi._loopTimestamp, 2500,
          '.playFromCurrent resets the timestamp from last updated position');
    });


    module('getEventNames');


    test('Returns a list of event names', function () {
      var rekapi = setupTestRekapi();
      deepEqual(rekapi.getEventNames(), _.keys(rekapi._events),
        'An accurate list of event string names is returned.');
    });


    module('Internals - Loops');


    test('Actor.tween correctly calculates position based on time in a finite loop',
        function () {

      var rekapi = setupTestRekapi();
      var actor = setupTestActor(rekapi);

      mockTime = function () {
        return 0;
      };

      actor
        .keyframe(0, {
          'x': 0
        })
        .keyframe(1000, {
          'x': 100
        });

      mockTime = function () {
        return 0;
      };

      rekapi.play(2);

      mockTime = function () {
        return 500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 50,
          'Actor property has the proper value for halfway between a loop iteration');

      mockTime = function () {
        return 1500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 50,
          'Actor property has the proper value for halfway between a loop iteration');

      mockTime = function () {
        return 2500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 100,
          'Loop sequence has completed, actor is locked at final position');
    });


    test('Actor.tween correctly calculates position based on time in an infinite loop',
        function () {

      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      mockTime = function () {
        return 0;
      };

      actor
        .keyframe(0, {
          'x': 0
        })
        .keyframe(1000, {
          'x': 100
        });

      mockTime = function () {
        return 0;
      };

      rekapi.play();

      mockTime = function () {
        return 500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 50,
          'Actor property has the proper value for halfway between a loop iteration');

      mockTime = function () {
        return 1500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 50,
          'Actor property has the proper value for halfway between a loop iteration');

      mockTime = function () {
        return 10000000500;
      };

      Rekapi._private.updateToCurrentMillisecond(rekapi);
      equal(actor.get().x, 50,
          'Loop sequence is still running at some distant point in the future');
    });


    module('Internals - calculateLoopPosition');


    test('Calculate accurate position in the tween', function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 1 })
        .keyframe(2000, { x: 2 });

      calculatedMillisecond =  Rekapi._private
        .calculateLoopPosition(rekapi, 1000, 0);

      equal(calculatedMillisecond, 1000,
          'Calculated a midpoint of the animation');
    });


    test('Calculate accurate overflow position in the tween', function () {
      var rekapi
          ,actor
          ,calculatedMillisecond;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 1 })
        .keyframe(2000, { x: 2 });

      calculatedMillisecond =
          Rekapi._private.calculateLoopPosition(rekapi, 2500, 1);

      equal(calculatedMillisecond, 500,
          'Calculated an overflow position of the animation');
    });


    module("Internals - determineCurrentLoopIteration");


    test('Calculate a given iteration of a loop', function () {
      var rekapi
          ,actor
          ,calculatedIteration;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, { x: 1 })
        .keyframe(2000, { x: 2 });

      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 0);

      equal(calculatedIteration, 0,
          'Calculated the beginning of the first iteration');


      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 1000);

      equal(calculatedIteration, 0,
          'Calculated the middle of the first iteration');


      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 1999);

      equal(calculatedIteration, 0,
          'Calculated the end of the first iteration');


      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 4000);

      equal(calculatedIteration, 2,
          'Calculated the beginning of an iteration greater than 1');


      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 5000);

      equal(calculatedIteration, 2,
          'Calculated the middle of an iteration greater than 1');


      calculatedIteration =
          Rekapi._private.determineCurrentLoopIteration(rekapi, 5999);

      equal(calculatedIteration, 2,
          'Calculated the end of an iteration greater than 1');
    });


    module('Internals - calculateTimeSinceStart');


    test('Calculate the delta of the current time and when the animation began'
      ,function () {
      var rekapi
          ,actor
          ,calculatedTime;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(2000, {});

      mockTime = function () {
        return 0;
      };

      rekapi.play();

      mockTime = function () {
        return 500;
      };

      calculatedTime = Rekapi._private.calculateTimeSinceStart(rekapi);
      equal(calculatedTime, 500,
          'The expected amount of time since beginning the animation was calculated');

    });


    module('Internals - isAnimationComplete');


    test('Determine if the animation has completed in a finite loop'
      ,function () {
      var rekapi
          ,actor
          ,animationIsComplete;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(2000, {});

      rekapi.play(3);

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 1);
      equal(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 2);
      equal(animationIsComplete, false,
          'The last iteration of a loop is condsider to be not complete');

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 3);
      equal(animationIsComplete, true,
          'An iteration after the specified amount of iterations is considered to be complete');
    });


    test('Determine if the animation has completed in an infinite loop'
      ,function () {
      var rekapi
          ,actor
          ,animationIsComplete;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(2000, {});

      rekapi.play();

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 1);
      equal(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 3);
      equal(animationIsComplete, false,
          'The animation is not complete');

      animationIsComplete = Rekapi._private.isAnimationComplete(rekapi, 1000);
      equal(animationIsComplete, false,
          'The animation is not complete');
    });


    module('Internals - updatePlayState');


    test('Determine if the animation\'s internal state is "playing" after evaluating a given iteration'
      ,function () {
      var rekapi
          ,actor;

      rekapi = setupTestRekapi();
      actor = setupTestActor(rekapi);

      actor
        .keyframe(0, {})
        .keyframe(2000, {});

      rekapi.play(3);

      Rekapi._private.updatePlayState(rekapi, 0);
      equal(rekapi.isPlaying(), true, 'The animation is still running');

      Rekapi._private.updatePlayState(rekapi, 2);
      equal(rekapi.isPlaying(), true, 'The animation is still running');

      Rekapi._private.updatePlayState(rekapi, 3);
      equal(rekapi.isPlaying(), false, 'The animation is still complete');
    });


    module('Function keyframes');


    test('Explicit calls to .update() reset all function keyframes later in the timeline', function () {
      var rekapi = new Rekapi();
      var actor = rekapi.addActor();

      var callCount = 0;
      actor
        .keyframe(10, {
          'function': function () {
            callCount++;
          }
          ,x: 0
        })
        .keyframe(20, {
          x: 10
        });

      rekapi._timesToIterate = 1;

      Rekapi._private.updateToMillisecond(rekapi, 5);
      equal(callCount, 0, 'The function was not called');

      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 1, 'The function was called once');

      rekapi.update(5);
      Rekapi._private.updateToMillisecond(rekapi, 15);
      equal(callCount, 2, 'The function was called twice');
    });


  } ());
  </script>
</head>
<body>
  <h1 id="qunit-header"><a href="https://github.com/jeremyckahn/rekapi">Rekapi</a></h1>
   <h2 id="qunit-banner"></h2>
   <div id="qunit-testrunner-toolbar"></div>
   <h2 id="qunit-userAgent"></h2>
   <ol id="qunit-tests"></ol>
   <div id="qunit-fixture"></div>
</body>
</html>
